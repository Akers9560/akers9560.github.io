<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Win10使用PowerShell首次执行hexo，出现”无法加载文件 xxx\AppData\Roaming\npm\hexo.ps1，因为在此系统上禁止运行脚本“解决办法</title>
    <url>/2021/07/21/abp0010/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote>
<p>Win10使用<code>npm</code>安装<code>hexo</code>之后，使用<code>PowerShell</code>执行<code>hexo init blog</code>报错，”无法加载文件 xxx\AppData\Roaming\npm\hexo.ps1，因为在此系统上禁止运行脚本“</p>
</blockquote>
<hr>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol>
<li><p>使用 <kbd>Win</kbd>+<kbd>I</kbd> 组合键打开设置面板。</p>
</li>
<li><p>在搜索框中输入<code>powershell</code>，弹出下拉框。</p>
</li>
<li><p>在下拉框中选择”允许本地PowerShell脚本在不签名的情况下运行“，此时会跳转到”开发者选项-&gt;PowerShell-&gt;应用一下设置以执行PowerShell脚本“。</p>
</li>
<li><p>下面的复选框会默认打勾（如果没打勾就自己打上），然后点击应用。</p>
</li>
<li><p>再次打开<code>PowerShell</code>，成功运行<code>hexo init blog</code>。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Windows</category>
      </categories>
  </entry>
  <entry>
    <title>Win10系统下使用telnet命令ping远程端口</title>
    <url>/2021/08/03/abp0011/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><blockquote>
<p>在<code>Win10</code>系统下，使用<code>ping</code>命令只能查看<code>80</code>端口通不通，如果要查看别的端口，就需要用到<code>telnet</code>命令。默认情况下，<code>telnet</code>命令是没有开启的，需要先启动这个命令</p>
</blockquote>
<hr>
<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><h3 id="打开系统的telnet命令"><a href="#打开系统的telnet命令" class="headerlink" title="打开系统的telnet命令"></a>打开系统的<code>telnet</code>命令</h3><ol>
<li>右键<code>开始</code>菜单，选择<code>文件资源管理器</code>，在搜索框内输入<code>控制面板\程序\程序和功能</code>进入到<code>程序和功能窗口</code><br><img src="win10_telnet_search.png" alt="文件资源管理器"></li>
<li>点击<code>启用或关闭Windows功能</code><br><img src="win10_telnet_click_enable_and_disable.png" alt="启用或关闭Windows功能"></li>
<li>在弹出的<code>Windows</code>功能窗口中，找到<code>Telnet客户端</code>，并勾选复选框<br><img src="win10_telnet_click_operation.png" alt="勾选Telnet客户端"></li>
<li>系统搜索需要等待一会儿，完成之后点击<code>关闭</code>即可<br><img src="win10_telnet_click_waiting.png" alt="勾选Telnet客户端"></li>
</ol>
<h3 id="使用telnet命令"><a href="#使用telnet命令" class="headerlink" title="使用telnet命令"></a>使用<code>telnet</code>命令</h3><ol>
<li>右键<code>开始</code>菜单，选择<code>Windows PowerShell(管理员)</code>打开<code>PowerShell</code>命令行</li>
<li>现在使用<code>telnet</code>测试一下远程<code>443</code>端口<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">telnet &lt;ip&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure>
<img src="win10_telnet_baidu_443.png" alt="Telnet百度443"></li>
<li>如果成功，<code>PowerShell</code>窗口会变空白，标题会变成<code>Telnet 远程的ip</code>，内容的首个字符会有个光标一直闪烁。多按几次<code>回车</code>可退出<code>telnet</code>模式<br><img src="win10_telnet_baidu_443_result.png" alt="Telnet百度443结果"></li>
<li>如果失败，<code>PowerShell</code>会一直显示<code>正在连接xxx.xxx.xxx.xxx...</code>，随后显示连接失败<br><img src="win10_telnet_google_443_fail.png" alt="Telnet谷歌443结果"></li>
</ol>
]]></content>
      <categories>
        <category>Windows</category>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title>如何使用 Markdown 编写技术文档</title>
    <url>/2021/08/03/abp0012/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p><a href="https://experienceleague.adobe.com/docs/contributor/contributor-guide/writing-essentials/markdown.html?lang=zh-Hans">如何使用 Markdown 编写技术文档</a> </p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Linux 格式化数据盘 挂载数据盘</title>
    <url>/2021/08/11/abp0013/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><blockquote>
<p>很多小伙伴使用Linux都会面临系统盘磁盘空间不够用的情况，这种时候就需要添加数据盘并且挂载上去使用</p>
</blockquote>
<hr>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>远程连接实例</p>
<p>运行 <code>fdisk -l</code> 命令查看实例是否有数据盘。如果执行命令后，没有发现 <code>/dev/vdb</code>，表示您的实例没有数据盘，无需格式化数据盘，请忽略本文后续内容。</p>
<p>创建一个单分区数据盘，依次执行以下命令：</p>
<ul>
<li>运行 <code>fdisk /dev/vdb</code>：分区数据盘。</li>
<li>输入 <code>n</code> 并按回车键：创建一个新分区。</li>
<li>输入 <code>p</code> 并按回车键：选择主分区。因为创建的是一个单分区数据盘，所以只需要创建主分区。</li>
<li>输入分区编号并按回车键。因为这里仅创建一个分区，可以输入 <code>1</code>。</li>
<li>输入第一个可用的扇区编号：按回车键采用默认值 <code>1</code>。</li>
<li>输入最后一个扇区编号：因为这里仅创建一个分区，所以按回车键采用默认值。</li>
<li>输入 <code>wq</code> 并按回车键，开始分区。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iXXXXXXX ~]<span class="comment"># fdisk /dev/vdb</span></span><br><span class="line">Device contains neither a valid DOS partition table, nor Sun, SGI or OSF disklabel</span><br><span class="line">Building a new DOS disklabel with disk identifier 0x5f46a8a2.</span><br><span class="line">Changes will remain <span class="keyword">in</span> memory only, until you decide to write them.</span><br><span class="line">After that, of course, the previous content won<span class="string">&#x27;t be recoverable.</span></span><br><span class="line"><span class="string">Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)</span></span><br><span class="line"><span class="string">WARNING: DOS-compatible mode is deprecated. It&#x27;</span>s strongly recommended to</span><br><span class="line">switch off the mode (<span class="built_in">command</span> <span class="string">&#x27;c&#x27;</span>) and change display units to</span><br><span class="line">sectors (<span class="built_in">command</span> <span class="string">&#x27;u&#x27;</span>).</span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Command action</span><br><span class="line">e extended</span><br><span class="line">p primary partition (1-4)</span><br><span class="line">p</span><br><span class="line">Partition number (1-4): 1</span><br><span class="line">First cylinder (1-41610, default 1): 1</span><br><span class="line">Last cylinder, +cylinders or +size&#123;K,M,G&#125; (1-41610, default 41610):</span><br><span class="line">Using default value 41610</span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): wq</span><br><span class="line">The partition table has been altered!</span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br></pre></td></tr></table></figure>

<p>查看新的分区：运行命令 <code>fdisk -l</code>。如果出现以下信息，说明已经成功创建了新分区 <code>/dev/vdb1</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iXXXXXXX ~]<span class="comment"># fdisk -l</span></span><br><span class="line">Disk /dev/vda: 42.9 GB, 42949672960 bytes</span><br><span class="line">255 heads, 63 sectors/track, 5221 cylinders</span><br><span class="line">Units = cylinders of 16065 * 512 = 8225280 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk identifier: 0x00053156</span><br><span class="line">Device Boot Start End Blocks Id System</span><br><span class="line">/dev/vda1 * 1 5222 41942016 83 Linux</span><br><span class="line">Disk /dev/vdb: 21.5 GB, 21474836480 bytes</span><br><span class="line">16 heads, 63 sectors/track, 41610 cylinders</span><br><span class="line">Units = cylinders of 1008 * 512 = 516096 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk identifier: 0x5f46a8a2</span><br><span class="line">Device Boot Start End Blocks Id System</span><br><span class="line">/dev/vdb1 1 41610 20971408+ 83 Linux</span><br></pre></td></tr></table></figure>

<p>在新分区上创建一个文件系统：运行命令 <code>mkfs.ext3 /dev/vdb1</code>。</p>
<p>本示例要创建一个 <code>ext3</code> 文件系统。您也可以根据自己的需要，选择创建其他文件系统，例如，如果需要在 Linux、Windows 和 Mac 系统之间共享文件，您可以使用 <code>mkfs.vfat</code> 创建 VFAT 文件系统。</p>
<p>创建文件系统所需时间取决于数据盘大小。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iXXXXXXX ~]<span class="comment"># mkfs.ext3 /dev/vdb1</span></span><br><span class="line">mke2fs 1.41.12 (17-May-2010)</span><br><span class="line">Filesystem label=</span><br><span class="line">OS <span class="built_in">type</span>: Linux</span><br><span class="line">Block size=4096 (<span class="built_in">log</span>=2)</span><br><span class="line">Fragment size=4096 (<span class="built_in">log</span>=2)</span><br><span class="line">Stride=0 blocks, Stripe width=0 blocks</span><br><span class="line">1310720 inodes, 5242852 blocks</span><br><span class="line">262142 blocks (5.00%) reserved <span class="keyword">for</span> the super user</span><br><span class="line">First data block=0</span><br><span class="line">Maximum filesystem blocks=4294967296</span><br><span class="line">160 block groups</span><br><span class="line">32768 blocks per group, 32768 fragments per group</span><br><span class="line">8192 inodes per group</span><br><span class="line">Superblock backups stored on blocks:</span><br><span class="line">32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208,</span><br><span class="line">4096000</span><br><span class="line">Writing inode tables: <span class="keyword">done</span></span><br><span class="line">Creating journal (32768 blocks): <span class="keyword">done</span></span><br><span class="line">Writing superblocks and filesystem accounting information: <span class="keyword">done</span></span><br><span class="line">This filesystem will be automatically checked every 37 mounts or</span><br><span class="line">180 days, whichever comes first. Use tune2fs -c or -i to override.</span><br></pre></td></tr></table></figure>

<p>（建议）备份 etc/fstab：运行命令 <code>cp /etc/fstab /etc/fstab.bak</code>。</p>
<p>向 <code>/etc/fstab</code> 写入新分区信息：运行命令 <code>echo /dev/vdb1 /mnt ext3 defaults 0 0 &gt;&gt; /etc/fstab</code>。如果需要把数据盘单独挂载到某个文件夹，比如单独用来存放网页，请将以上命令 <code>/mnt</code> 替换成所需的挂载点路径。</p>
<p>查看 <code>/etc/fstab</code> 中的新分区信息：运行命令 <code>cat /etc/fstab</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iXXXXXXX ~]<span class="comment"># cat /etc/fstab</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># /etc/fstab</span></span><br><span class="line"><span class="comment"># Created by anaconda on Thu Feb 23 07:28:22 2017</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Accessible filesystems, by reference, are maintained under &#x27;/dev/disk&#x27;</span></span><br><span class="line"><span class="comment"># See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">UUID=3d083579-f5d9-4df5-9347-8d27925805d4 / ext4 defaults 1 1</span><br><span class="line">tmpfs /dev/shm tmpfs defaults 0 0</span><br><span class="line">devpts /dev/pts devpts gid=5,mode=620 0 0</span><br><span class="line">sysfs /sys sysfs defaults 0 0</span><br><span class="line">proc /proc proc defaults 0 0</span><br><span class="line">/dev/vdb1 /mnt ext3 defaults 0 0</span><br></pre></td></tr></table></figure>



<p>挂载文件系统：运行命令 <code>mount /dev/vdb1 /mnt</code>。</p>
<p>查看目前磁盘空间和使用情况：运行命令 <code>df -h</code>。如果出现新建文件系统的信息，说明挂载成功，可以使用新的文件系统了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@iXXXXXXX ~]<span class="comment"># mount /dev/vdb1 /mnt</span></span><br><span class="line">[root@iXXXXXXX ~]<span class="comment"># df -h</span></span><br><span class="line">Filesystem Size Used Avail Use% Mounted on</span><br><span class="line">/dev/vda1 40G 6.6G 31G 18% /</span><br><span class="line">tmpfs 499M 0 499M 0% /dev/shm</span><br><span class="line">/dev/vdb1 20G 173M 19G 1% /mnt</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Docker查看容器资源占用情况</title>
    <url>/2021/08/11/abp0014/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><blockquote>
<p>有些时候<code>Docker</code>集群项目出现问题，需要快速查找问题所在，这种时候首先就需要查看<code>Docker</code>的各个容器是否有资源使用不正常的情况</p>
</blockquote>
<hr>
<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><p>使用<code>docker stats</code> 命令用来显示容器使用的系统资源。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stats</span><br></pre></td></tr></table></figure>

<p>默认输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CONTAINER           CPU %               MEM USAGE / LIMIT       MEM %               NET I/O             BLOCK I/O           PIDS</span><br><span class="line">d7ef5139ea28        0.10%               273.3 MiB / 1.796 GiB   14.86%              302 MB / 305 MB     269 MB / 0 B        29</span><br><span class="line">083e9f44bf1b        0.00%               5.859 MiB / 1.796 GiB   0.32%               3.05 GB / 3.07 GB   339 MB / 0 B        9</span><br><span class="line">996236181fa3        0.50%               11.79 MiB / 1.796 GiB   0.64%               3.39 GB / 4.04 GB   183 MB / 0 B        9</span><br><span class="line">1b610486dbcf        0.00%               43.05 MiB / 1.796 GiB   2.34%               1.33 GB / 488 MB    21.3 GB / 248 MB    16</span><br><span class="line">3934362529c3        0.03%               280.1 MiB / 1.796 GiB   15.23%              567 MB / 1.16 GB    6.91 GB / 517 MB    39</span><br></pre></td></tr></table></figure>

<p>可以看到输出上面内容的情况下，会每隔1秒钟刷新一次输出的内容。按下 <kbd>Ctrl</kbd>+<kbd>C</kbd> 可以结束。下面是输出的内容的说明：</p>
<ul>
<li>[CONTAINER]：以短格式显示容器的 ID。</li>
<li>[CPU %]：CPU 的使用情况。</li>
<li>[MEM USAGE / LIMIT]：当前使用的内存和最大可以使用的内存。</li>
<li>[MEM %]：以百分比的形式显示内存使用情况。</li>
<li>[NET I/O]：网络 I/O 数据。</li>
<li>[BLOCK I/O]：磁盘 I/O 数据。</li>
<li>[PIDS]：PID 号。</li>
</ul>
<p>如果只需要查看当时状态，可以使用<code>--no-stream</code>，输出之后命令行会自动结束</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stats --no-stream</span><br></pre></td></tr></table></figure>

<p>很明显按照上面这种情况，如果容器太多了，我们很难去对应是输出的哪一个容器的信息。这个时候就需要使用<code>--format</code>将返回结果按照自己需要的内容输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stats --format <span class="string">&quot;table &#123;&#123;.Container&#125;&#125;\t&#123;&#123;.Name&#125;&#125;\t&#123;&#123;.CPUPerc&#125;&#125;\t&#123;&#123;.MemUsage&#125;&#125;\t&#123;&#123;.NetIO&#125;&#125;\t&#123;&#123;.BlockIO&#125;&#125;\t&#123;&#123;.MemPerc&#125;&#125;\t&#123;&#123;.PIDs&#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<p>这样就能很容易的对应自己设置容器名称</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CONTAINER           NAME                CPU %               MEM USAGE / LIMIT       NET I/O             BLOCK I/O           MEM %               PIDS</span><br><span class="line">d7ef5139ea28        blog                0.12%               273.3 MiB / 1.796 GiB   304 MB / 306 MB     269 MB / 0 B        14.86%              29</span><br><span class="line">083e9f44bf1b        v2ray-usa           0.00%               5.977 MiB / 1.796 GiB   3.05 GB / 3.07 GB   339 MB / 0 B        0.32%               9</span><br><span class="line">996236181fa3        v2ray               0.40%               11.8 MiB / 1.796 GiB    3.41 GB / 4.06 GB   183 MB / 0 B        0.64%               9</span><br><span class="line">1b610486dbcf        gogs                0.00%               43.02 MiB / 1.796 GiB   1.33 GB / 488 MB    21.3 GB / 248 MB    2.34%               16</span><br><span class="line">3934362529c3        mysql               0.04%               280.1 MiB / 1.796 GiB   567 MB / 1.16 GB    6.91 GB / 517 MB    15.23%              39</span><br></pre></td></tr></table></figure>

<p>下面是<code>--format</code>可自定义的占位符</p>
<table>
<thead>
<tr>
<th align="left">符号</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>.Container</code></td>
<td align="left">容器的名称或 ID</td>
</tr>
<tr>
<td align="left"><code>.Name</code></td>
<td align="left">容器名称</td>
</tr>
<tr>
<td align="left"><code>.ID</code></td>
<td align="left">容器 ID</td>
</tr>
<tr>
<td align="left"><code>.CPUPerc</code></td>
<td align="left">CPU 使用率</td>
</tr>
<tr>
<td align="left"><code>.MemUsage</code></td>
<td align="left">内存使用量</td>
</tr>
<tr>
<td align="left"><code>.NetIO</code></td>
<td align="left">网络 I/O</td>
</tr>
<tr>
<td align="left"><code>.BlockIO</code></td>
<td align="left">磁盘 I/O</td>
</tr>
<tr>
<td align="left"><code>.MemPerc</code></td>
<td align="left">内存使用率</td>
</tr>
<tr>
<td align="left"><code>.PIDs</code></td>
<td align="left">PID 号</td>
</tr>
</tbody></table>
<p>有些时候为了方便处理，也可以将<code>--format</code>按照<code>json</code>格式输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stats --no-stream --format <span class="string">&quot;&#123;\&quot;container\&quot;:\&quot;&#123;&#123; .Container &#125;&#125;\&quot;,\&quot;memory\&quot;:&#123;\&quot;raw\&quot;:\&quot;&#123;&#123; .MemUsage &#125;&#125;\&quot;,\&quot;percent\&quot;:\&quot;&#123;&#123; .MemPerc &#125;&#125;\&quot;&#125;,\&quot;cpu\&quot;:\&quot;&#123;&#123; .CPUPerc &#125;&#125;\&quot;&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">&quot;container&quot;</span>:<span class="string">&quot;d7ef5139ea28&quot;</span>,<span class="string">&quot;memory&quot;</span>:&#123;<span class="string">&quot;raw&quot;</span>:<span class="string">&quot;273.3 MiB / 1.796 GiB&quot;</span>,<span class="string">&quot;percent&quot;</span>:<span class="string">&quot;14.86%&quot;</span>&#125;,<span class="string">&quot;cpu&quot;</span>:<span class="string">&quot;0.10%&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;container&quot;</span>:<span class="string">&quot;083e9f44bf1b&quot;</span>,<span class="string">&quot;memory&quot;</span>:&#123;<span class="string">&quot;raw&quot;</span>:<span class="string">&quot;6.078 MiB / 1.796 GiB&quot;</span>,<span class="string">&quot;percent&quot;</span>:<span class="string">&quot;0.33%&quot;</span>&#125;,<span class="string">&quot;cpu&quot;</span>:<span class="string">&quot;0.00%&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;container&quot;</span>:<span class="string">&quot;996236181fa3&quot;</span>,<span class="string">&quot;memory&quot;</span>:&#123;<span class="string">&quot;raw&quot;</span>:<span class="string">&quot;11.88 MiB / 1.796 GiB&quot;</span>,<span class="string">&quot;percent&quot;</span>:<span class="string">&quot;0.65%&quot;</span>&#125;,<span class="string">&quot;cpu&quot;</span>:<span class="string">&quot;0.31%&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;container&quot;</span>:<span class="string">&quot;1b610486dbcf&quot;</span>,<span class="string">&quot;memory&quot;</span>:&#123;<span class="string">&quot;raw&quot;</span>:<span class="string">&quot;42.93 MiB / 1.796 GiB&quot;</span>,<span class="string">&quot;percent&quot;</span>:<span class="string">&quot;2.33%&quot;</span>&#125;,<span class="string">&quot;cpu&quot;</span>:<span class="string">&quot;0.00%&quot;</span>&#125;</span><br><span class="line">&#123;<span class="string">&quot;container&quot;</span>:<span class="string">&quot;3934362529c3&quot;</span>,<span class="string">&quot;memory&quot;</span>:&#123;<span class="string">&quot;raw&quot;</span>:<span class="string">&quot;280.1 MiB / 1.796 GiB&quot;</span>,<span class="string">&quot;percent&quot;</span>:<span class="string">&quot;15.23%&quot;</span>&#125;,<span class="string">&quot;cpu&quot;</span>:<span class="string">&quot;0.04%&quot;</span>&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>关于JAVA发送Https请求（HttpsURLConnection和HttpURLConnection）</title>
    <url>/2021/08/13/abp0016/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><code>https</code>协议对于开发者而言其实只是多了一步证书验证的过程。这个证书正常情况下被<code>jdk/jre/security/cacerts</code>所管理。里面证书包含两种情况：</p>
<ol>
<li>机构所颁发的被认证的证书，这种证书的网站在浏览器访问时<code>https</code>头显示为绿色如百度</li>
<li>个人生成的证书，这种证书的网站在浏览器里<code>https</code>头显示为红色×，且需要点击信任该网站才能继续访问。而点击信任这一步的操作就是我们在<code>java</code>代码访问<code>https</code>网站时区别于<code>http</code>请求需要做的事情。</li>
</ol>
<hr>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p><code>JAVA</code>发送<code>Https</code>请求有两种情况，三种解决办法</p>
<p>一、 <code>Https</code>网站的证书为机构所颁发的被认证的证书，这种情况下和<code>http</code>请求一模一样，无需做任何改变，用<code>HttpsURLConnection</code>或者<code>HttpURLConnection</code>都可以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">    URL serverUrl = new URL(&quot;https://xxxx&quot;);</span><br><span class="line">    HttpURLConnection conn = (HttpURLConnection) serverUrl.openConnection();</span><br><span class="line">    conn.setRequestMethod(&quot;GET&quot;);</span><br><span class="line">    conn.setRequestProperty(&quot;Content-type&quot;, &quot;application/json&quot;);</span><br><span class="line">    //必须设置false，否则会自动redirect到重定向后的地址</span><br><span class="line">    conn.setInstanceFollowRedirects(false);</span><br><span class="line">    conn.connect();</span><br><span class="line">    String result = getReturn(conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*请求url获取返回的内容*/</span><br><span class="line">public static String getReturn(HttpURLConnection connection) throws IOException&#123;</span><br><span class="line">    StringBuffer buffer = new StringBuffer();</span><br><span class="line">    //将返回的输入流转换成字符串</span><br><span class="line">    try(InputStream inputStream = connection.getInputStream();</span><br><span class="line">        InputStreamReader inputStreamReader = new InputStreamReader(inputStream, ConstantInfo.CHARSET);</span><br><span class="line">        BufferedReader bufferedReader = new BufferedReader(inputStreamReader);)&#123;</span><br><span class="line">        String str = null;</span><br><span class="line">        while ((str = bufferedReader.readLine()) != null) &#123;</span><br><span class="line">            buffer.append(str);</span><br><span class="line">        &#125;</span><br><span class="line">        String result = buffer.toString();</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二、 个人所设定的证书，这种证书默认不被信任，需要我们自己选择信任，信任的办法有两种：<br>将证书导入<code>java</code>的运行环境中</p>
<p>从该网站下载或者从网站开发者出获取证书<code>cacert.crt</code></p>
<p>运行命令将证书导入<code>java</code>运行环境：<code>keytool -import -keystore %JAVA_HOME%\jre\lib\security\cacerts -file cacert.crt -alias xxx</code></p>
<p>完成。<code>java</code>代码中发送<code>https</code>的请求和<code>http</code>一样，同第一种情况。</p>
<p>忽略证书验证过程，忽略之后任何<code>Https</code>协议网站皆能正常访问，同第一种情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.security.cert.CertificateException;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.X509Certificate;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.X509TrustManager;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyX509TrustManager</span> <span class="keyword">implements</span> <span class="title">X509TrustManager</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(X509Certificate certificates[],String authType)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(X509Certificate[] ax509certificate,String s)</span> <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        SSLContext sslcontext = SSLContext.getInstance(<span class="string">&quot;SSL&quot;</span>,<span class="string">&quot;SunJSSE&quot;</span>);</span><br><span class="line">        sslcontext.init(<span class="keyword">null</span>, <span class="keyword">new</span> TrustManager[]&#123;<span class="keyword">new</span> MyX509TrustManager()&#125;, <span class="keyword">new</span> java.security.SecureRandom());</span><br><span class="line">        URL url = <span class="keyword">new</span> URL(<span class="string">&quot;https://xxxx&quot;</span>);</span><br><span class="line">        HostnameVerifier ignoreHostnameVerifier = <span class="keyword">new</span> HostnameVerifier() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String s, SSLSession sslsession)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;WARNING: Hostname is not matched for cert.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        HttpsURLConnection.setDefaultHostnameVerifier(ignoreHostnameVerifier);</span><br><span class="line">        HttpsURLConnection.setDefaultSSLSocketFactory(sslcontext.getSocketFactory());</span><br><span class="line">        <span class="comment">//之后任何Https协议网站皆能正常访问，同第一种情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>java</code>代码中加载证书，必须使用<code>HttpsURLConnection</code>方式</p>
<p>从网站开发者出获取生成证书的密钥库<code>cacert.keystore</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyStore;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.CertificateException;</span><br><span class="line"><span class="keyword">import</span> java.security.cert.X509Certificate;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.TrustManager;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.TrustManagerFactory;</span><br><span class="line"><span class="keyword">import</span> javax.net.ssl.X509TrustManager;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyX509TrustManager</span> <span class="keyword">implements</span> <span class="title">X509TrustManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The default X509TrustManager returned by SunX509.  We&#x27;ll delegate</span></span><br><span class="line"><span class="comment">     * decisions to it, and fall back to the logic in this class if the</span></span><br><span class="line"><span class="comment">     * default X509TrustManager doesn&#x27;t trust it.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    X509TrustManager sunJSSEX509TrustManager;</span><br><span class="line">    MyX509TrustManager() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// create a &quot;default&quot; JSSE X509TrustManager.</span></span><br><span class="line">        KeyStore ks = KeyStore.getInstance(<span class="string">&quot;JKS&quot;</span>);</span><br><span class="line">        ks.load(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;cancert.keystore&quot;</span>),</span><br><span class="line">                <span class="string">&quot;changeit&quot;</span>.toCharArray());</span><br><span class="line">        TrustManagerFactory tmf =</span><br><span class="line">                TrustManagerFactory.getInstance(<span class="string">&quot;SunX509&quot;</span>, <span class="string">&quot;SunJSSE&quot;</span>);</span><br><span class="line">        tmf.init(ks);</span><br><span class="line">        TrustManager tms [] = tmf.getTrustManagers();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Iterate over the returned trustmanagers, look</span></span><br><span class="line"><span class="comment">             * for an instance of X509TrustManager.  If found,</span></span><br><span class="line"><span class="comment">             * use that as our &quot;default&quot; trust manager.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tms.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tms[i] <span class="keyword">instanceof</span> X509TrustManager) &#123;</span><br><span class="line">                sunJSSEX509TrustManager = (X509TrustManager) tms[i];</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Find some other way to initialize, or else we have to fail the</span></span><br><span class="line"><span class="comment">             * constructor.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;Couldn&#x27;t initialize&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Delegate to the default trust manager.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkClientTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sunJSSEX509TrustManager.checkClientTrusted(chain, authType);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CertificateException excep) &#123;</span><br><span class="line">            <span class="comment">// do any special handling here, or rethrow exception.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Delegate to the default trust manager.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">checkServerTrusted</span><span class="params">(X509Certificate[] chain, String authType)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> CertificateException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sunJSSEX509TrustManager.checkServerTrusted(chain, authType);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CertificateException excep) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Possibly pop up a dialog box asking whether to trust the</span></span><br><span class="line"><span class="comment">                 * cert chain.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Merely pass this through.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="keyword">public</span> X509Certificate[] getAcceptedIssuers() &#123;</span><br><span class="line">        <span class="keyword">return</span> sunJSSEX509TrustManager.getAcceptedIssuers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        SSLContext sslcontext = SSLContext.getInstance(<span class="string">&quot;SSL&quot;</span>,<span class="string">&quot;SunJSSE&quot;</span>);</span><br><span class="line">        sslcontext.init(<span class="keyword">null</span>, <span class="keyword">new</span> TrustManager[]&#123;<span class="keyword">new</span> MyX509TrustManager()&#125;, <span class="keyword">new</span> java.security.SecureRandom());</span><br><span class="line">        URL serverUrl = <span class="keyword">new</span> URL(<span class="string">&quot;https://xxxx&quot;</span>);</span><br><span class="line">        HttpsURLConnection conn = (HttpsURLConnection) serverUrl.openConnection();</span><br><span class="line">        conn.setSSLSocketFactory(sslcontext.getSocketFactory());</span><br><span class="line">        conn.setRequestMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">        conn.setRequestProperty(<span class="string">&quot;Content-type&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        <span class="comment">//必须设置false，否则会自动redirect到重定向后的地址</span></span><br><span class="line">        conn.setInstanceFollowRedirects(<span class="keyword">false</span>);</span><br><span class="line">        conn.connect();</span><br><span class="line">        String result = getReturn(conn);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getReturn</span><span class="params">(HttpsURLConnection connection)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="comment">//将返回的输入流转换成字符串</span></span><br><span class="line">        <span class="keyword">try</span>(InputStream inputStream = connection.getInputStream();</span><br><span class="line">            InputStreamReader inputStreamReader = <span class="keyword">new</span> InputStreamReader(inputStream, ConstantInfo.CHARSET);</span><br><span class="line">            BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(inputStreamReader);)&#123;</span><br><span class="line">            String str = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((str = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                buffer.append(str);</span><br><span class="line">            &#125;</span><br><span class="line">            String result = buffer.toString();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>Https</category>
      </categories>
  </entry>
  <entry>
    <title>Chia正式网络水龙头免费领取XCH</title>
    <url>/2021/08/10/abp0004/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul>
<li><p>Chia正式网络水龙头<br><a href="https://faucet.chia.net/">https://faucet.chia.net/</a></p>
</li>
<li><p>网站用到Google人机身份验证，可能需要科学上网</p>
</li>
</ul>
]]></content>
      <categories>
        <category>BlockChain</category>
        <category>Chia</category>
      </categories>
  </entry>
  <entry>
    <title>Docker的overlay2目录占用大，迁移docker工作目录的方法</title>
    <url>/2021/08/02/abp0005/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><blockquote>
<p>在生产环境中，会经常遇到<code>docker</code>容器占用空间过大，系统盘磁盘空间不足的情况，随着使用量越来越大，这种时候仅仅是扩容系统盘已经无法完全解决这个问题，此时就需要挂载一个数据盘，本文挂载到目录<code>/mnt</code>下，然后将<code>docker</code>工作目录迁移到<code>/mnt</code></p>
</blockquote>
<hr>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ol>
<li><p>先查看<code>docker</code>工作目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker info |grep &quot;Docker Root Dir&quot;</span><br></pre></td></tr></table></figure>
<p>显示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Docker Root Dir: /var/lib/docker</span><br></pre></td></tr></table></figure></li>
<li><p>关闭<code>docker</code>服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop docker.service</span><br></pre></td></tr></table></figure></li>
<li><p>移动目录到挂载的数据盘<code>/mnt</code>下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv /var/lib/docker /mnt/docker</span><br></pre></td></tr></table></figure></li>
<li><p>修改<code>docker</code>启动配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /usr/lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure>
<p>有些系统是在这个目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure>
<p>在<code>ExecStart=/usr/bin/dockerd</code>这行后追加<code>--graph=/mnt/docker</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --graph=/mnt/docker </span><br></pre></td></tr></table></figure></li>
<li><p>重新加载，重启<code>docker</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl start docker.service</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="Docker的一些其它命令"><a href="#Docker的一些其它命令" class="headerlink" title="Docker的一些其它命令"></a><code>Docker</code>的一些其它命令</h3><blockquote>
<p>类似于Linux上的df命令，用于查看Docker的磁盘使用情况</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker system df</span><br></pre></td></tr></table></figure>
<blockquote>
<p>列出所有dangling(虚悬)镜像，也就是 TAG 为 &lt;none&gt; 的</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker images -f dangling=true</span><br></pre></td></tr></table></figure>
<blockquote>
<p>用于清理磁盘，删除关闭的容器、无用的数据卷和网络，以及dangling(虚悬)镜像</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker system prune</span><br></pre></td></tr></table></figure>
<blockquote>
<p>清理得更加彻底，可以将没有容器使用Docker镜像都删掉（请慎重操作）</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker system prune -a</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Ubuntu</category>
        <category>Docker</category>
      </categories>
  </entry>
  <entry>
    <title>Filecoin(Lotus)测试网络Calibration水龙头免费领取FIL</title>
    <url>/2021/08/09/abp0006/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><ul>
<li><p>Filecoin(Lotus)测试网络Calibration水龙头<br><a href="https://faucet.calibration.fildev.network/">https://faucet.calibration.fildev.network/</a></p>
</li>
<li><p>可能需要科学上网</p>
</li>
</ul>
]]></content>
      <categories>
        <category>BlockChain</category>
        <category>Filecoin</category>
      </categories>
  </entry>
  <entry>
    <title>Java逐行读取某个目录下所有文件的内容</title>
    <url>/2021/08/02/abp0007/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><blockquote>
<p>先获取目录<code>basePath</code>下面的文件名组数，再通过目录+文件名的方式读取每一个文件，最后通过<code>BufferedReader</code>的<code>readLine</code>功能读取文件内容</p>
</blockquote>
<hr>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>直接上代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.StandardCharsets;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadFileTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        String basePath = <span class="string">&quot;C:/Users/Administrator/Desktop/filedir&quot;</span>;</span><br><span class="line">        String[] list = <span class="keyword">new</span> File(basePath).list();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;file not found&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String filename : list) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;filename: &quot;</span> + filename);</span><br><span class="line">            BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(basePath + <span class="string">&quot;/&quot;</span> + filename), StandardCharsets.UTF_8));</span><br><span class="line">            String str;</span><br><span class="line">            <span class="keyword">while</span> ((str = in.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(str);</span><br><span class="line">            &#125;</span><br><span class="line">            in.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu20.04开机启动时出现A start job is running for wait for network to be Configured长时间等待的解决办法</title>
    <url>/2021/07/28/abp0008/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><blockquote>
<p>官方Ubuntu20.04安装完成之后，开机启动时出现A start job is running for wait for network to be Configured (10s / no limit)，会造成长时间等待，开机时间过长。</p>
</blockquote>
<hr>
<h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><ol>
<li>系统启动，如果没有接入网线或者网线没有插好，会导致获取不了网络长时间等待</li>
<li>新增加了网口配置，但是配置错误；或者新增加的网口对应的网线不通</li>
</ol>
<hr>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p><strong>一、暴力解决，设置等待超时时间</strong></p>
<ol>
<li><p>一直等待是因为下面这个服务无法正常启动造成的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl status systemd-networkd-wait-online.service</span><br></pre></td></tr></table></figure>
<p><img src="systemd-networkd-wait-online-status.png" alt="查看状态为Failed"></p>
</li>
<li><p>修改服务对应的配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/systemd/system/network-online.target.wants/systemd-networkd-wait-online.service</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>[Service]</code>下添加一行，设置为等待5秒超时</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">TimeoutStartSec=5sec</span><br></pre></td></tr></table></figure>
<p>修改前</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">ExecStart=/lib/systemd/systemd-networkd-wait-online</span><br><span class="line">RemainAfterExit=yes</span><br></pre></td></tr></table></figure>
<p>修改后</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">ExecStart=/lib/systemd/systemd-networkd-wait-online</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line">TimeoutStartSec=5sec</span><br></pre></td></tr></table></figure></li>
<li><p>修改完成之后重启系统，此时等待5秒超时系统就会自动跳过等待的步骤</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo reboot now</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<p><strong>二、修改网口配置</strong></p>
<ol>
<li><p>查看服务运行状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl status systemd-networkd-wait-online.service</span><br></pre></td></tr></table></figure>
<p><img src="systemd-networkd-wait-online-status.png" alt="查看状态为Failed"></p>
</li>
<li><p>查看网口是否正常配置，其中<code>enp161s0f0</code>网口一直处于<code>configuring</code>状态，可见就是这个网口造成的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">networkctl</span><br></pre></td></tr></table></figure>
<p><img src="networkctl-status.png" alt="查看网口配置"></p>
</li>
<li><p>查找这个网口是在哪个配置文件里面配置的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo grep -l enp161s0f0 /etc/netplan/*</span><br></pre></td></tr></table></figure>
<p><img src="netplan-config.png" alt="查找网口配置文件"></p>
</li>
<li><p>修改文件配置，我们需要去掉这个配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/netplan/00-installer-config.yaml</span><br></pre></td></tr></table></figure>
<p><img src="comment-error-config.png" alt="注释掉对应的网口"></p>
</li>
<li><p>检查配置文件是否修改正确</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo netplan generate</span><br></pre></td></tr></table></figure></li>
<li><p>应用网络配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure></li>
<li><p>查看网口配置，没有处于<code>configuring</code>状态的网口了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">networkctl</span><br></pre></td></tr></table></figure>
<p><img src="networkctl-status2.png" alt="查看网口配置"></p>
</li>
<li><p>重启服务，查看服务状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart systemd-networkd-wait-online.service</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl status systemd-networkd-wait-online.service</span><br></pre></td></tr></table></figure>
<p><img src="systemd-nerworkd-wait-online-active.png" alt="服务运行成功"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>Linux修改SSH默认的22端口及关闭密码认证登录</title>
    <url>/2021/07/26/abp0009/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h3 id="修改端口"><a href="#修改端口" class="headerlink" title="修改端口"></a>修改端口</h3><ol>
<li><p>修改sshd配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></li>
<li><p>编辑添加新的端口，默认Port=22</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Port=8888</span><br></pre></td></tr></table></figure></li>
<li><p>重启sshd</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h3 id="关闭密码登录"><a href="#关闭密码登录" class="headerlink" title="关闭密码登录"></a>关闭密码登录</h3><ol>
<li><p>修改sshd配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br></pre></td></tr></table></figure></li>
<li><p>找到<code>PasswordAuthentication</code>，修改<code>yes</code>为<code>no</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PasswordAuthentication no</span><br></pre></td></tr></table></figure></li>
<li><p>重启sshd</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service sshd restart</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Ubuntu</category>
        <category>SSH</category>
      </categories>
  </entry>
  <entry>
    <title>修改Spring Boot启动时的默认图案Banner</title>
    <url>/2019/01/18/abp0001/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><p><strong>一、替换banner</strong></p>
<ol>
<li>在src/main/resources路径下新建一个banner.txt文件，并输入想要的内容。</li>
<li>可以使用在线生成文字图案的网站生成  <a href="http://patorjk.com/software/taag/">在线生成文字图案</a></li>
</ol>
<p><strong>二、关闭banner</strong></p>
<p>修改main方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//SpringApplication.run(Application.class, args);</span></span><br><span class="line">		SpringApplication newRun= <span class="keyword">new</span> SpringApplication(Application.class); </span><br><span class="line">		newRun.setBannerMode(Banner.Mode.OFF);</span><br><span class="line">		newRun.run(args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>SpringBoot</category>
      </categories>
  </entry>
  <entry>
    <title>Linux使用tar打包和解压</title>
    <url>/2019/09/24/abp0002/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h3 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h3><p>打包一个目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zcf ***.tar.gz /path</span><br></pre></td></tr></table></figure>

<p>解压文件到一个目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -zxvf ***.tar.gz</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Ubuntu</category>
        <category>SSH</category>
      </categories>
  </entry>
  <entry>
    <title>搭建Omni（USDT）本地测试环境，并模拟发布USDT代币</title>
    <url>/2021/07/29/abp0003/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h3 id="运行Omni钱包Regtest（本地测试环境）节点"><a href="#运行Omni钱包Regtest（本地测试环境）节点" class="headerlink" title="运行Omni钱包Regtest（本地测试环境）节点"></a>运行Omni钱包Regtest（本地测试环境）节点</h3><blockquote>
<p>文章基于<code>Windows10</code>系统上运行<code>Omnicore</code>，其它系统同理</p>
</blockquote>
<ol>
<li><p>下载<code>Omnicore</code>，解压</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="function">https://<span class="title">github.com</span>/<span class="title">OmniLayer</span>/<span class="title">omnicore</span>/<span class="title">releases</span>/<span class="title">download</span>/<span class="title">v0</span>.11.0/<span class="title">omnicore</span>-0.11.0-<span class="title">win64.zip</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>进入到目录下</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\Users\Administrator\Downloads\omnicore-<span class="number">0</span>.<span class="number">11</span>.<span class="number">0</span>\bin</span><br></pre></td></tr></table></figure></li>
<li><p>运行本地测试节点</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">omnicore-qt.exe -datadir=./ -rpcuser=rpcuser123 -rpcpassword=password123 -server=<span class="number">1</span> -rpcallowip=<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>/<span class="number">0</span> -port=<span class="number">18444</span> -rpcport=<span class="number">10332</span> -listen -chain=regtest -fallbackfee=<span class="number">0</span>.<span class="number">00001</span></span><br><span class="line">#-rpcuser=&lt;user&gt; 设置JSON-RPC连接认证的用户</span><br><span class="line">#-rpcpassword=&lt;pw&gt; 设置JSON-RPC连接认证的密码</span><br><span class="line">#-server 开启命令行和JSON-RPC调用</span><br><span class="line">#-datadir=&lt;<span class="built_in">dir</span>&gt; 数据存放目录，相对目录时请使用`<span class="built_in">CMD</span>`工具，`Power Shell`无法使用相对路径运行</span><br><span class="line">#-rpcallowip=<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>/<span class="number">0</span> 设置允许JSON-RPC调用的IP，这里测试网络设置的<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>/<span class="number">0</span>，正式网络谨慎使用</span><br><span class="line">#-port=<span class="number">18444</span> 节点网络监听端口</span><br><span class="line">#-rpcport=<span class="number">18443</span> 节点JSON-RPC监听端口</span><br><span class="line">#-listen 允许外部连接，使用多节点时需要开启</span><br><span class="line">#-chain=regtest 指定为本地测试环境，不指定默认为主网</span><br><span class="line">#-fallbackfee=<span class="number">0</span>.<span class="number">00001</span></span><br></pre></td></tr></table></figure></li>
<li><p>启动之后经过短暂的加载页面，可以看到如下界面，目录也在当前目录下<br><img src="omni-regtest-homepage.png" alt="Bitcoin regtest页面"><br><img src="omni-regtest-dir.png" alt="Bitcoin regtest目录"></p>
</li>
</ol>
<hr>
<h3 id="如何模拟BTC挖矿"><a href="#如何模拟BTC挖矿" class="headerlink" title="如何模拟BTC挖矿"></a>如何模拟BTC挖矿</h3><ol>
<li><p>打开<code>OmniCore</code>的控制台，窗口-&gt;控制台</p>
</li>
<li><p>生成一个地址用来存放挖矿收益</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">getnewaddress</span><br></pre></td></tr></table></figure>
<p><img src="omni-regtest-getnewaddress.png" alt="Bitcoin regtest获取一个新的地址"></p>
</li>
<li><p>开始手动挖矿，新挖出的BTC在可以使用前必须经过101个区块确认的成熟过程</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">generatetoaddress <span class="number">101</span> <span class="number">2</span>NDNJ4EHMKreNXXpFknqFWU6sjxNQemZrvN</span><br></pre></td></tr></table></figure>
<p><img src="omni-regtest-generatetoaddress.png" alt="Bitcoin regtest手动挖101个块"><br>此时切换到概况页面可以看到有50BTC，这50BTC就是挖的第一个块的奖励<br><img src="omni-regtest-homepagebalance.png" alt="Bitcoin regtest首页查看余额"></p>
</li>
</ol>
<hr>
<h3 id="如何模拟发布USDT代币（Token）"><a href="#如何模拟发布USDT代币（Token）" class="headerlink" title="如何模拟发布USDT代币（Token）"></a>如何模拟发布USDT代币（Token）</h3><ol>
<li><p>为了区分，再创建一个新的地址</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">getnewaddress</span><br></pre></td></tr></table></figure>
<p><img src="omni-regtest-getnewaddress2.png" alt="Bitcoin regtest获取一个新的地址"></p>
</li>
<li><p>往新地址发送10个BTC</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">sendtoaddress <span class="number">2</span>NAZiD97N1WsJpQhw1z6n798NekdhycWHzY <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p><img src="omni-regtest-sendtoaddress.png" alt="Bitcoin regtest发送10个BTC"><br>手动挖一个块，确认这笔交易</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">generatetoaddress <span class="number">1</span> <span class="number">2</span>NDNJ4EHMKreNXXpFknqFWU6sjxNQemZrvN</span><br></pre></td></tr></table></figure></li>
<li><p>创建一个可管理的Token，记住返回的交易哈希</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">omni_sendissuancemanaged &quot;<span class="number">2</span>NAZiD97N1WsJpQhw1z6n798NekdhycWHzY&quot; <span class="number">1</span> <span class="number">2</span> <span class="number">0</span> &quot;Financial and insurance activities&quot; &quot;Activities auxiliary to financial service and insurance activities&quot; &quot;TetherUS&quot; &quot;https://tether.to&quot; &quot;The next paradigm of money.&quot; </span><br></pre></td></tr></table></figure>
<p><img src="omni-regtest-sendissuancemanaged.png" alt="Bitcoin regtest创建一个Token"><br>手动挖一个块，确认这笔交易</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">generatetoaddress <span class="number">1</span> <span class="number">2</span>NDNJ4EHMKreNXXpFknqFWU6sjxNQemZrvN</span><br></pre></td></tr></table></figure></li>
<li><p>获取这笔交易，都是创建的Token的详情，记住下面的<code>propertyid</code>，此处为<code>3</code></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">omni_gettransaction <span class="number">81</span>f7a3408bb01fc41bdfb697403a493f1b601f7223be72ae2776df60baf8d54f</span><br></pre></td></tr></table></figure>
<p><img src="omni-regtest-omnigettokentransaction.png" alt="Bitcoin regtest获取token详情"></p>
</li>
<li><p>使用创建Token的地址发行代币，下面的<code>&quot;&quot;</code>表示发行到哪个地址，空表示发行到自己，此处即<code>2NAZiD97N1WsJpQhw1z6n798NekdhycWHzY</code>，<code>3</code>就是上一个步骤的<code>propertyid</code>，<code>10000</code>是发行数量</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">omni_sendgrant <span class="number">2</span>NAZiD97N1WsJpQhw1z6n798NekdhycWHzY &quot;&quot; <span class="number">3</span> <span class="number">10000</span> &quot;First&quot;</span><br></pre></td></tr></table></figure>
<p>手动挖一个块，确认这笔交易</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">generatetoaddress <span class="number">1</span> <span class="number">2</span>NDNJ4EHMKreNXXpFknqFWU6sjxNQemZrvN</span><br></pre></td></tr></table></figure>
<p>此时查看发行地址<code>2NAZiD97N1WsJpQhw1z6n798NekdhycWHzY</code>，已经有<code>10000</code>余额</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">omni_getbalance <span class="number">2</span>NAZiD97N1WsJpQhw1z6n798NekdhycWHzY <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><img src="omni-regtest-omnigetbalance.png" alt="Bitcoin regtest查看发行地址余额"></p>
</li>
<li><p>此时可以将代币发送到其它地址</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">omni_send <span class="number">2</span>NAZiD97N1WsJpQhw1z6n798NekdhycWHzY <span class="number">2</span>NDNJ4EHMKreNXXpFknqFWU6sjxNQemZrvN <span class="number">3</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>
<p>手动挖一个块，确认这笔交易</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">generatetoaddress <span class="number">1</span> <span class="number">2</span>NDNJ4EHMKreNXXpFknqFWU6sjxNQemZrvN</span><br></pre></td></tr></table></figure>
<p>查询余额</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">omni_getbalance <span class="number">2</span>NDNJ4EHMKreNXXpFknqFWU6sjxNQemZrvN <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><img src="omni-regtest-omnigetbalance2.png" alt="Bitcoin regtest查看接收地址余额"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>BlockChain</category>
        <category>Bitcoin</category>
        <category>Omni</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu更新系统时间</title>
    <url>/2021/08/31/abp0017/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>服务器上用了<code>Google</code>验证器，由于服务器时间有时会或快或慢，超过<code>Google</code>验证器的时限之后会导致总是验证不通过，这个时候需要更新系统时间。</p>
<hr>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><ol>
<li><p>安装ntpdate</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ntpdate</span><br></pre></td></tr></table></figure></li>
<li><p>同步系统时间</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ntpdate cn.pool.ntp.org</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>收藏实用工具</title>
    <url>/2021/09/02/abp0018/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>记录一些平时使用到的实用工具</p>
<hr>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><ul>
<li><p>美国地址生成器，可以随机生成美国地址，可用于注册亚马逊、苹果ID等</p>
<p><a href="https://www.meiguodizhi.com/">美国地址生成器</a></p>
</li>
</ul>
<ul>
<li><p>Unicode字符工具</p>
<p><a href="https://unicode-table.com/cn/">Unicode字符工具</a><br><a href="https://unicode-table.com/cn/tools/flip/">将文字和字母倒转的工具</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title>Ubuntu20.04使用python报错ImportError No module named requests</title>
    <url>/2021/09/14/abp0020/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><code>Ubuntu</code>安装<code>python</code>之后，导入<code>requests</code>模块报错ImportError: No module named requests，使用<code>pip install requests</code>安装成功但是使用的时候依然报错</p>
<p>这个时候需要使用<code>python2.7 pip</code>代替默认<code>pip</code></p>
<hr>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><ol>
<li><p><code>$PATH</code>变量中的某个位置应安装一个名为<code>pip2.7</code>的二进制文件。可以使用下面的命令查找</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> pip2.7</span><br></pre></td></tr></table></figure></li>
<li><p>这应该在标准输出上打印<code>/usr/local/bin/pip2.7</code>之类的内容。 如果它不打印任何类似内容，则表示未安装。 在这种情况下，请通过运行安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://bootstrap.pypa.io/pip/2.7/get-pip.py</span><br><span class="line">sudo python2.7 get-pip.py</span><br></pre></td></tr></table></figure></li>
<li><p>再次查看应该会打印<code>/usr/local/bin/pip2.7</code>，说明替换成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> pip2.7</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>pip2.7</code>安装<code>requests</code>模块，<code>python</code>命令已经可以使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip2.7 install requests</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title>Linux查询当前工作目录下的所有目录（文件夹）</title>
    <url>/2021/09/14/abp0019/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>查询当前工作目录下的所有目录（文件夹）</p>
<hr>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><ol>
<li><p>如果当前目录下面全是文件夹，在每个文件夹下创建一个<code>logs</code>目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> `ls`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">mkdir -p <span class="variable">$x</span>/logs</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果当前目录下面不全是文件夹，在每个文件夹下创建一个<code>logs</code>目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> `ls -F | grep <span class="string">&#x27;/$&#x27;</span>`</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">mkdir -p <span class="variable">$x</span><span class="string">&quot;&quot;</span>logs</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Ubuntu</category>
      </categories>
  </entry>
  <entry>
    <title>Nodejs安装http-server启动本地服务</title>
    <url>/2021/09/17/abp0021/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>在本地调试<code>html</code>静态文件的时候，通常会遇到<code>js</code>加载或者跨域问题，这个时候就需要本地启动一个服务，通常情况下使用<code>http-server</code>是最方便快捷的</p>
<hr>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><ol>
<li><p>查看<code>nodejs</code>是否安装，如果没安装请先下载安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure></li>
<li><p>安装<code>http-server</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g http-server</span><br></pre></td></tr></table></figure></li>
<li><p>进入需要访问的目录，比如我是将随意一个<code>index.html</code>放在桌面<code>C:\Users\Administrator\Desktop</code>下，我们将要访问这个<code>index.html</code>文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\Users\Administrator\Desktop</span><br></pre></td></tr></table></figure></li>
<li><p>启动<code>http-server</code>服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http-server</span><br></pre></td></tr></table></figure></li>
<li><p>出现下面的内容之后，可选择一个路径进行访问</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Available on:</span><br><span class="line">  http://172.19.160.1:8080</span><br><span class="line">  http://192.169.8.138:8080</span><br><span class="line">  http://192.168.15.1:8080</span><br><span class="line">  http://192.168.6.1:8080</span><br><span class="line">  http://127.0.0.1:8080</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Nodejs</category>
      </categories>
  </entry>
  <entry>
    <title>WPS Excel专题使用及详解</title>
    <url>/2021/09/18/abp0022/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>记录一些WPS Excel中经常需要用到的功能</p>
<hr>
<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><h4 id="VLOOKUP"><a href="#VLOOKUP" class="headerlink" title="VLOOKUP"></a>VLOOKUP</h4><p><code>VLOOKUP</code>可以用来核对数据，多个表格之间快速导入数据等函数功能。功能是按列查找，最终返回该列所需查询序列所对应的值；与之对应的<code>HLOOKUP</code>是按行查找的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VLOOKUP (lookup_value, table_array, col_index_num, [range_lookup])</span><br></pre></td></tr></table></figure>


<blockquote>
<blockquote>
<ul>
<li><code>Lookup_value</code>为需要在数据表第一列中进行查找的数值。<code>Lookup_value</code>可以为数值、引用或文本字符串。<br>当<code>vlookup</code>函数第一参数省略查找值时，表示用0查找。</li>
<li><code>Table_array</code>为需要在其中查找数据的数据表。使用对区域或区域名称的引用。</li>
<li><code>col_index_num</code>为<code>table_array</code>中查找数据的数据列序号。<code>col_index_num</code>为<code>1</code>时，返回<code>table_array</code>第一列的数值，<br><code>col_index_num</code>为<code>2</code>时，返回<code>table_array</code>第二列的数值，以此类推。<br>如果<code>col_index_num</code>小于<code>1</code>，函数<code>VLOOKUP</code>返回错误值<code>#VALUE!</code>；<br>如果<code>col_index_num</code>大于<code>table_array</code>的列 数，函数<code>VLOOKUP</code>返回错误值<code>#REF!</code>。</li>
<li><code>Range_lookup</code>为一逻辑值，指明函数<code>VLOOKUP</code>查找时是精确匹配，还是近似匹配。<br>如果为FALSE或0，则返回精确匹配，如果找不到，则返回错误值<code>#N/A</code>。<br>如果<code>range_lookup</code>为<code>TRUE</code>或<code>1</code>，函数<code>VLOOKUP</code>将查找近似匹配值，也就是说，如果找不到精确匹配值，则返回小于<code>lookup_value</code>的最大数值。<br>如果<code>range_lookup</code>省略，则默认为<code>1</code>。</li>
</ul>
</blockquote>
</blockquote>
<ol>
<li><p>首先拿到两组数据如下<br><img src="vlookup_1.png" alt="门牌号和户主名"><img src="vlookup_2.png" alt="门牌号和人口数"></p>
</li>
<li><p>把这两组数据通过门牌号组合在一起</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">=VLOOKUP(D2,I:J,2,FALSE)</span><br></pre></td></tr></table></figure>
<p><img src="vlookup_3.png" alt="VLOOKUP函数"></p>
</li>
<li><p>按下回车之后，就会出现第一个匹配结果<br><img src="vlookup_4.png" alt="VLOOKUP函数结果"></p>
</li>
<li><p>这时在函数单元格使用<strong>填充柄</strong>填充其他单元格即可完成操作<br><img src="vlookup_5.png" alt="VLOOKUP函数结果填充"></p>
</li>
</ol>
<p>未完待续…</p>
]]></content>
      <categories>
        <category>WPS</category>
        <category>Excel</category>
      </categories>
  </entry>
  <entry>
    <title>Vim专题使用及详解</title>
    <url>/2021/08/12/abp0015/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><hr>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><blockquote>
<p>由于在服务器的使用当中，有些时候需要在服务器上面直接修改一些内容，有个强大的工具叫<code>Vim</code>，但是<code>Vim</code>的使用又非常复杂，这里做一篇专门的教程记录一些平时常需要用到的功能。</p>
</blockquote>
<hr>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li>Ubuntu<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install vim</span><br></pre></td></tr></table></figure></li>
<li>CentOS<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install vim</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="简单模式"><a href="#简单模式" class="headerlink" title="简单模式"></a>简单模式</h3><ul>
<li>直接打开一个文件的编辑模式<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim &lt;filename&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<p>未完待续…</p>
]]></content>
      <categories>
        <category>Linux</category>
        <category>Vim</category>
      </categories>
  </entry>
</search>
